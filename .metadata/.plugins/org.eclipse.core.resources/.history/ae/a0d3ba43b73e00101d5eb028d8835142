/*
 * generated by Xtext 2.37.0
 */
package org.xtext.example.smarthome.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtend2.lib.StringConcatenation
import org.xtext.example.smarthome.smartHome.Room
import org.xtext.example.smarthome.smartHome.Expression
import org.xtext.example.smarthome.smartHome.GT
import org.xtext.example.smarthome.smartHome.LT
import org.xtext.example.smarthome.smartHome.AND
import org.xtext.example.smarthome.smartHome.VarRef
import org.eclipse.emf.common.util.EList
import org.xtext.example.smarthome.smartHome.MyNumber
import org.xtext.example.smarthome.smartHome.Parenthesis
import org.eclipse.xtext.EcoreUtil2
import org.xtext.example.smarthome.smartHome.Controller
import org.xtext.example.smarthome.smartHome.RoomInheritanceDetails
import org.xtext.example.smarthome.smartHome.Device
import org.xtext.example.smarthome.smartHome.DeviceInheritanceDetails
import org.xtext.example.smarthome.smartHome.Property
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SmartHomeGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {	
	val sc = new StringConcatenation
	for (e: resource.allContents.toIterable.filter(Room)){
			sc.append(e.compile)
			sc.newLine()
			//fsa.generateFile(e.name.toFirstLower + ".py", e.compile)
		}
		
		fsa.generateFile("main.py", sc)
	}
	
	def compile(Room room){
		val parentRoom = getRoomParent(room)
		val parentRoomProperties = if (parentRoom !== null) parentRoom.properties else newArrayList
	'''
	class «room.name.toFirstUpper»«IF parentRoom !==null»(«parentRoom.name»)«ENDIF»:
	    «IF room.properties.size == 0 && room.devices.size== 0 && parentRoomProperties.size == 0»pass
	    «ELSE»def __init__(self, «IF parentRoomProperties.size > 0»«printPropertiesName(parentRoomProperties)»«IF room.properties.size > 0», «ENDIF»«ENDIF»«printPropertiesName(room.properties)»):
	        «IF parentRoomProperties.size > 0»super().__init__(«printPropertiesName(parentRoomProperties)»)«ENDIF»
	        «initializationProperties(room.properties)»	        
	    
	    «printGetSetPrivateProperties(room.properties)»
	       
	    «FOR dev: room.devices»
		    «val parentDevice = getDevideParent(dev)»
		    «val parentDeviceProperties = if (parentDevice !== null) parentDevice.properties else newArrayList»
	    class «dev.name.toFirstUpper»«IF parentDevice !==null»(«parentDevice.name»)«ENDIF»:
	        «IF dev.properties.size == 0 && dev.actions.size== 0 && parentDeviceProperties.size == 0»pass
	        «ELSE»def __init__(self, «IF parentDeviceProperties.size > 0»«printPropertiesName(parentDeviceProperties)»«IF dev.properties.size > 0», «ENDIF»«ENDIF»«printPropertiesName(dev.properties)»):
	            «IF parentDeviceProperties.size > 0»super().__init__(«FOR pro: parentDeviceProperties SEPARATOR ', '»«pro.name»«ENDFOR»)«ENDIF»
	            «FOR dev_pro: dev.properties»
	            «IF dev.exp.size == 0 || hasPropertyConstraint(dev.exp, dev_pro.name) === false»
	            self.«IF dev_pro.prType!==null && dev_pro.prType.name == "private"»__«ELSE»«ENDIF»«dev_pro.name» = «dev_pro.name»
	            «ELSE»
	            if «getPropertyConstraint(dev.exp, dev_pro.name).complieExpByDispatch»:
	                self.«IF dev_pro.prType!==null && dev_pro.prType.name == "private"»__«ELSE»«ENDIF»«dev_pro.name» = «dev_pro.name»
	            else:
	                 raise ValueError("Invalid value")
	            «ENDIF»
	            «ENDFOR»
        «FOR pro: dev.properties.filter[t | t.prType!==null && t.prType.name == "private"]»def get_«pro.name»(self):
            return self.__«pro.name»
        def set_«pro.name»(self, «pro.name»):
            self.__«pro.name» = «pro.name»
        «ENDFOR»
	        «ENDIF»
	        «FOR action: dev.actions»
	        def «action.name»(self):
	            print("Start «action.name»!")
	        «ENDFOR»
	     «ENDFOR»
	     «ENDIF»
	'''
	} 

	def String printGetSetPrivateProperties(List<Property> properties){
		return '''«FOR pro: properties.filter[t | t.prType!==null && t.prType.name == "private"]»
		# For get private property
		def get_«pro.name»(self):
		    return self.__«pro.name»
		
		# For set private property
		def set_«pro.name»(self, «pro.name»):
			self.__«pro.name» = «pro.name»
        «ENDFOR»
		'''
	}
	
	def String printPropertiesName(List<Property> properties){
		return '''«FOR pro: properties SEPARATOR ', '»«pro.name»«ENDFOR»'''
	}
	
	def String initializationProperties(List<Property> properties){
		return '''«FOR pro: properties»
		self.«IF pro.prType!==null && pro.prType.name == "private"»__«ELSE»«ENDIF»«pro.name» = «pro.name»
        «ENDFOR»'''
	}


	def boolean hasPropertyConstraint(EList<Expression> expList, String propertyName) {
	    if (expList === null || expList.empty) return false
	
	    for (exp : expList) {
 			if (checkExpressionByDispatch(exp, propertyName)) {
	            return true
	        }
	    }
	    return false
	}
	
	def Expression getPropertyConstraint(EList<Expression> expList, String propertyName) {
	    if (expList === null || expList.empty) return null
	
	    for (exp : expList) {
	        if (checkExpressionByDispatch(exp, propertyName)) {
	            return exp
	        }
	    }
	    return null
	}
	
	def dispatch boolean checkExpressionByDispatch(GT ex, String propertyName){
		return checkExpressionByDispatch(ex.left, propertyName)
	}
	
	def dispatch boolean checkExpressionByDispatch(LT ex, String propertyName){
		return checkExpressionByDispatch(ex.left, propertyName)
	}
	
	def dispatch boolean checkExpressionByDispatch(AND ex, String propertyName){
		return checkExpressionByDispatch(ex.left, propertyName)
	}
	
	def dispatch boolean checkExpressionByDispatch(VarRef ex, String propertyName){
		return ex.value.name.equals(propertyName)
	}
	
	def dispatch boolean checkExpressionByDispatch(Number ex, String propertyName){
		return false
	}
	
	def dispatch boolean checkExpressionByDispatch(Expression ex, String propertyName){
		return false
	}
		
	def dispatch String complieExpByDispatch(GT ex){
		return ex.left.complieExpByDispatch + " > " + ex.right.complieExpByDispatch
	}
	
	def dispatch String complieExpByDispatch(LT ex){
		return ex.left.complieExpByDispatch + " < " + ex.right.complieExpByDispatch
	}
	
	def dispatch String complieExpByDispatch(AND ex){
		return ex.left.complieExpByDispatch + " and " + ex.right.complieExpByDispatch
	}
	
	def dispatch String complieExpByDispatch(Parenthesis ex){
		return '(' + ex.value.complieExpByDispatch +')'
	}
	
	def dispatch String complieExpByDispatch(MyNumber ex){
		return ex.value.toString()
	}
	
	def dispatch String complieExpByDispatch(VarRef ex){
		return ex.value.name
	}
	
	def Room getRoomParent(Room room){
		var root = EcoreUtil2.getContainerOfType(room, Controller)
		if (root === null || root.roomInheritance === null || root.roomInheritance.inheritances === null)
        return null		
		var inheritance = root.roomInheritance.inheritances.filter(RoomInheritanceDetails).findFirst[roomChild == room]
		if(inheritance !== null)
			return inheritance.roomParent
		return null
	}
	
	def Device getDevideParent(Device device){
		var room = EcoreUtil2.getContainerOfType(device, Room)
		if (room === null || room.deviceInheritance === null || room.deviceInheritance.inheritances === null)
        return null		
		var inheritance = room.deviceInheritance.inheritances.filter(DeviceInheritanceDetails).findFirst[deviceChild == device]
		if(inheritance !== null)
			return inheritance.deviceParent
		return null
	}
	
	
//	def boolean checkExpression(Expression exp, String propertyName) {
//	    if (exp === null) return false
//	
//	    switch exp {
//	        GT: return checkExpression(exp.left, propertyName)// || checkExpression(exp.right, propertyName)
//	        LT: return checkExpression(exp.left, propertyName) //|| checkExpression(exp.right, propertyName)
//	        AND: return checkExpression(exp.left, propertyName)// || checkExpression(exp.right, propertyName)
//	        VarRef: return exp.value.name.equals(propertyName)
//	        Number: return false
//	        Expression: return false
//	        default: return false
//	    }
//	}
//	
//	def String compileExp(Expression exp) {
//		switch exp {
//			GT: return exp.left.compileExp + " > " + exp.right.compileExp
//			LT: return exp.left.compileExp + " < " + exp.right.compileExp
//			AND: return exp.left.compileExp + " and " + exp.right.compileExp
//			MyNumber: exp.value.toString()
//			VarRef: exp.value.name
//		}
//	}
	
//	def printDefault(Type t){
//		''' = «IF t.name == "BOOL"»False«ELSEIF t.name == "INTEGER"»0«ELSEIF t.name == "DOUBLE"»0.0«ELSE»""«ENDIF»'''
//	}
}
