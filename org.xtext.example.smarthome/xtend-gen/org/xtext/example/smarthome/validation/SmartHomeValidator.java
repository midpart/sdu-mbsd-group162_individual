/**
 * generated by Xtext 2.38.0
 */
package org.xtext.example.smarthome.validation;

import com.google.common.collect.Iterables;
import java.util.HashSet;
import java.util.Objects;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.smarthome.smartHome.Controller;
import org.xtext.example.smarthome.smartHome.Device;
import org.xtext.example.smarthome.smartHome.DeviceInheritanceDetails;
import org.xtext.example.smarthome.smartHome.Property;
import org.xtext.example.smarthome.smartHome.Room;
import org.xtext.example.smarthome.smartHome.RoomInheritanceDetails;
import org.xtext.example.smarthome.smartHome.SmartHomePackage;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SmartHomeValidator extends AbstractSmartHomeValidator {
  public static final String INVALID_NAME = "invalidName";

  public static final String CIRCULAR_INHERITANCE = "inheritance";

  public static final String DUPLICATE_CLASS_NAME = "duplicate class name";

  public static final String SINGLE_INHERITANCE = "inheritance";

  public static final String PROPERTY_ALREADY_DECLARE = "property already declare";

  @Check
  public void checkControllerNameStartsWithCapital(final Controller controller) {
    boolean _isUpperCase = Character.isUpperCase(controller.getName().charAt(0));
    boolean _equals = (_isUpperCase == false);
    if (_equals) {
      this.error("Controller name should start with a capital letter", SmartHomePackage.Literals.CONTROLLER__NAME, SmartHomeValidator.INVALID_NAME);
    }
  }

  @Check
  public void checkRoomNameStartsWithCapital(final Room room) {
    boolean _isUpperCase = Character.isUpperCase(room.getName().charAt(0));
    boolean _equals = (_isUpperCase == false);
    if (_equals) {
      this.error("Room name should start with a capital letter", SmartHomePackage.Literals.ROOM__NAME, SmartHomeValidator.INVALID_NAME);
    }
  }

  @Check
  public void checkDuplicateRoomName(final Room room) {
    Controller root = EcoreUtil2.<Controller>getContainerOfType(room, Controller.class);
    final Function1<Room, Boolean> _function = (Room t) -> {
      return Boolean.valueOf(((t != room) && Objects.equals(t.getName(), room.getName())));
    };
    int _size = IterableExtensions.size(IterableExtensions.<Room>filter(root.getRooms(), _function));
    boolean duplicateName = (_size > 0);
    if ((duplicateName == true)) {
      this.error("This room name already exists", SmartHomePackage.Literals.ROOM__NAME, SmartHomeValidator.DUPLICATE_CLASS_NAME);
    }
  }

  @Check
  public void checkDuplicateDeviceName(final Device device) {
    Room room = EcoreUtil2.<Room>getContainerOfType(device, Room.class);
    if (((room == null) || (room.getDevices() == null))) {
      return;
    }
    final Function1<Device, Boolean> _function = (Device t) -> {
      return Boolean.valueOf(((t != device) && Objects.equals(t.getName(), device.getName())));
    };
    int _size = IterableExtensions.size(IterableExtensions.<Device>filter(room.getDevices(), _function));
    boolean duplicateName = (_size > 0);
    if ((duplicateName == true)) {
      String _name = room.getName();
      String _plus = ("This device name already exists in this" + _name);
      this.error(_plus, SmartHomePackage.Literals.DEVICE__NAME, SmartHomeValidator.DUPLICATE_CLASS_NAME);
    }
  }

  @Check
  public void checkDeviceNameStartsWithCapital(final Device device) {
    boolean _isUpperCase = Character.isUpperCase(device.getName().charAt(0));
    boolean _equals = (_isUpperCase == false);
    if (_equals) {
      this.error("Device name should start with a capital letter", SmartHomePackage.Literals.ROOM__NAME, SmartHomeValidator.INVALID_NAME);
    }
  }

  @Check
  public void checkPropertiesNameDuplicate(final Property property) {
    final EObject container = property.eContainer();
    if ((container != null)) {
      if ((container instanceof Room)) {
        final Room room = ((Room) container);
        if ((room != null)) {
          final Function1<Property, Boolean> _function = (Property it) -> {
            return Boolean.valueOf(((it != property) && Objects.equals(it.getName(), property.getName())));
          };
          final Iterable<Property> duplicates = IterableExtensions.<Property>filter(room.getProperties(), _function);
          boolean _isEmpty = IterableExtensions.isEmpty(duplicates);
          boolean _not = (!_isEmpty);
          if (_not) {
            String _name = property.getName();
            String _plus = ("Duplicate property name in the same room: " + _name);
            this.error(_plus, 
              SmartHomePackage.Literals.PROPERTY__NAME, SmartHomeValidator.PROPERTY_ALREADY_DECLARE);
          }
          final Room parent = this.getRoomParent(room);
          if ((parent != null)) {
            final Function1<Property, Boolean> _function_1 = (Property it) -> {
              EObject _eContainer = it.eContainer();
              return Boolean.valueOf(Objects.equals(_eContainer, parent));
            };
            final Iterable<Property> parentRoomOnlyProperties = IterableExtensions.<Property>filter(parent.getProperties(), _function_1);
            final Function1<Property, Boolean> _function_2 = (Property it) -> {
              return Boolean.valueOf(((it != property) && Objects.equals(it.getName(), property.getName())));
            };
            final Iterable<Property> parentDuplicates = IterableExtensions.<Property>filter(parentRoomOnlyProperties, _function_2);
            boolean _isEmpty_1 = IterableExtensions.isEmpty(parentDuplicates);
            boolean _not_1 = (!_isEmpty_1);
            if (_not_1) {
              String _name_1 = property.getName();
              String _plus_1 = ("Duplicate property name from parent room: " + _name_1);
              this.error(_plus_1, 
                SmartHomePackage.Literals.PROPERTY__NAME, SmartHomeValidator.PROPERTY_ALREADY_DECLARE);
            }
          }
        }
      } else {
        if ((container instanceof Device)) {
          final Device device = ((Device) container);
          if ((device != null)) {
            final Function1<Property, Boolean> _function_3 = (Property it) -> {
              return Boolean.valueOf(((it != property) && Objects.equals(it.getName(), property.getName())));
            };
            final Iterable<Property> duplicates_1 = IterableExtensions.<Property>filter(device.getProperties(), _function_3);
            boolean _isEmpty_2 = IterableExtensions.isEmpty(duplicates_1);
            boolean _not_2 = (!_isEmpty_2);
            if (_not_2) {
              String _name_2 = property.getName();
              String _plus_2 = ("Duplicate property name in the same device: " + _name_2);
              this.error(_plus_2, 
                SmartHomePackage.Literals.PROPERTY__NAME, SmartHomeValidator.PROPERTY_ALREADY_DECLARE);
            }
            final Device parent_1 = this.getDeviceParent(device);
            if ((parent_1 != null)) {
              final Function1<Property, Boolean> _function_4 = (Property it) -> {
                EObject _eContainer = it.eContainer();
                return Boolean.valueOf(Objects.equals(_eContainer, parent_1));
              };
              final Iterable<Property> parentOnlyProperties = IterableExtensions.<Property>filter(parent_1.getProperties(), _function_4);
              final Function1<Property, Boolean> _function_5 = (Property it) -> {
                return Boolean.valueOf(((it != property) && Objects.equals(it.getName(), property.getName())));
              };
              final Iterable<Property> parentDuplicates_1 = IterableExtensions.<Property>filter(parentOnlyProperties, _function_5);
              boolean _isEmpty_3 = IterableExtensions.isEmpty(parentDuplicates_1);
              boolean _not_3 = (!_isEmpty_3);
              if (_not_3) {
                String _name_3 = property.getName();
                String _plus_3 = ("Duplicate property name from parent device: " + _name_3);
                this.error(_plus_3, 
                  SmartHomePackage.Literals.PROPERTY__NAME, SmartHomeValidator.PROPERTY_ALREADY_DECLARE);
              }
            }
          }
        }
      }
    }
  }

  @Check
  public void checkCircularInheritanceForRoom(final RoomInheritanceDetails inheritanceDetails) {
    final Room child = inheritanceDetails.getRoomChild();
    Room parent = inheritanceDetails.getRoomParent();
    int circuitBreak = 100;
    final HashSet<Room> visited = CollectionLiterals.<Room>newHashSet(child);
    while ((parent != null)) {
      {
        boolean _add = visited.add(parent);
        boolean _not = (!_add);
        if (_not) {
          this.error(
            "Circular Inheritance Detected", 
            SmartHomePackage.Literals.ROOM_INHERITANCE_DETAILS__ROOM_CHILD, 
            SmartHomeValidator.CIRCULAR_INHERITANCE);
          return;
        }
        parent = this.getRoomParent(parent);
        circuitBreak--;
        if ((circuitBreak < 0)) {
          this.error(
            "Circular Inheritance Detection check overflow", 
            SmartHomePackage.Literals.ROOM_INHERITANCE_DETAILS__ROOM_CHILD, 
            SmartHomeValidator.CIRCULAR_INHERITANCE);
          return;
        }
      }
    }
  }

  @Check
  public void checkOneClassInheritanceForRoom(final RoomInheritanceDetails inheritanceDetails) {
    final Room child = inheritanceDetails.getRoomChild();
    Controller root = EcoreUtil2.<Controller>getContainerOfType(child, Controller.class);
    if ((((root == null) || (root.getRoomInheritance() == null)) || (root.getRoomInheritance().getInheritances() == null))) {
      return;
    }
    final Function1<RoomInheritanceDetails, Boolean> _function = (RoomInheritanceDetails t) -> {
      Room _roomChild = t.getRoomChild();
      return Boolean.valueOf(Objects.equals(_roomChild, child));
    };
    int _size = IterableExtensions.size(IterableExtensions.<RoomInheritanceDetails>filter(Iterables.<RoomInheritanceDetails>filter(root.getRoomInheritance().getInheritances(), RoomInheritanceDetails.class), _function));
    boolean parentCount = (_size > 1);
    if ((Boolean.valueOf(parentCount) == Boolean.valueOf(true))) {
      this.error(
        "You can only inheritance from on base class", 
        SmartHomePackage.Literals.ROOM_INHERITANCE_DETAILS__ROOM_CHILD, 
        SmartHomeValidator.SINGLE_INHERITANCE);
    }
  }

  @Check
  public void checkOneClassInheritanceForDevice(final DeviceInheritanceDetails inheritanceDetails) {
    final Device child = inheritanceDetails.getDeviceChild();
    Room root = EcoreUtil2.<Room>getContainerOfType(child, Room.class);
    if ((((root == null) || (root.getDeviceInheritance() == null)) || (root.getDeviceInheritance().getInheritances() == null))) {
      return;
    }
    final Function1<DeviceInheritanceDetails, Boolean> _function = (DeviceInheritanceDetails t) -> {
      Device _deviceChild = t.getDeviceChild();
      return Boolean.valueOf(Objects.equals(_deviceChild, child));
    };
    int _size = IterableExtensions.size(IterableExtensions.<DeviceInheritanceDetails>filter(Iterables.<DeviceInheritanceDetails>filter(root.getDeviceInheritance().getInheritances(), DeviceInheritanceDetails.class), _function));
    boolean parentCount = (_size > 1);
    if ((Boolean.valueOf(parentCount) == Boolean.valueOf(true))) {
      this.error(
        "You can only inheritance from on base class", 
        SmartHomePackage.Literals.DEVICE_INHERITANCE_DETAILS__DEVICE_CHILD, 
        SmartHomeValidator.SINGLE_INHERITANCE);
    }
  }

  @Check
  public void checkCircularInheritanceForDevice(final DeviceInheritanceDetails inheritanceDetails) {
    final Device child = inheritanceDetails.getDeviceChild();
    Device parent = inheritanceDetails.getDeviceParent();
    int circuitBreak = 100;
    final HashSet<Device> visited = CollectionLiterals.<Device>newHashSet(child);
    while ((parent != null)) {
      {
        boolean _add = visited.add(parent);
        boolean _not = (!_add);
        if (_not) {
          this.error(
            "Circular Inheritance Detected", 
            SmartHomePackage.Literals.DEVICE_INHERITANCE_DETAILS__DEVICE_CHILD, 
            SmartHomeValidator.CIRCULAR_INHERITANCE);
          return;
        }
        parent = this.getDeviceParent(parent);
        circuitBreak--;
        if ((circuitBreak < 0)) {
          this.error(
            "Circular Inheritance Detection check overflow", 
            SmartHomePackage.Literals.DEVICE_INHERITANCE_DETAILS__DEVICE_CHILD, 
            SmartHomeValidator.CIRCULAR_INHERITANCE);
          return;
        }
      }
    }
  }

  public Room getRoomParent(final Room room) {
    Controller root = EcoreUtil2.<Controller>getContainerOfType(room, Controller.class);
    if ((((root == null) || (root.getRoomInheritance() == null)) || (root.getRoomInheritance().getInheritances() == null))) {
      return null;
    }
    final Function1<RoomInheritanceDetails, Boolean> _function = (RoomInheritanceDetails it) -> {
      Room _roomChild = it.getRoomChild();
      return Boolean.valueOf(Objects.equals(_roomChild, room));
    };
    RoomInheritanceDetails inheritance = IterableExtensions.<RoomInheritanceDetails>findFirst(Iterables.<RoomInheritanceDetails>filter(root.getRoomInheritance().getInheritances(), RoomInheritanceDetails.class), _function);
    if ((inheritance != null)) {
      return inheritance.getRoomParent();
    }
    return null;
  }

  public Device getDeviceParent(final Device device) {
    Room room = EcoreUtil2.<Room>getContainerOfType(device, Room.class);
    if ((((room == null) || (room.getDeviceInheritance() == null)) || (room.getDeviceInheritance().getInheritances() == null))) {
      return null;
    }
    final Function1<DeviceInheritanceDetails, Boolean> _function = (DeviceInheritanceDetails it) -> {
      Device _deviceChild = it.getDeviceChild();
      return Boolean.valueOf(Objects.equals(_deviceChild, device));
    };
    DeviceInheritanceDetails inheritance = IterableExtensions.<DeviceInheritanceDetails>findFirst(Iterables.<DeviceInheritanceDetails>filter(room.getDeviceInheritance().getInheritances(), DeviceInheritanceDetails.class), _function);
    if ((inheritance != null)) {
      return inheritance.getDeviceParent();
    }
    return null;
  }
}
